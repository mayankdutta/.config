# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

snippet num "number Theory"

template <typename INT> INT GCD(INT a, INT b) {
	return b ? gcd(b, a%b) : a;
}

template <typename INT> INT LCM(INT a, INT b) {
	return a / gcd(a, b) * b;
}

template <typename INT> std::map<INT, int> factorize(INT n) {
	map<INT, int> mp;
	for (INT i = 2; i * i <= n; i++) {
		while (n % i == 0) {
			n /= i;
			mp[i] ++;
		}
	}

	if (n > 1) mp[n] += 1;
	return mp;
}

ll bin_pow(ll a, ll b) {
	if (b == 0) return 1;
	long long res = bin_pow(a, b / 2);
	if (b % 2) return res * res * a;
	else return res * res;
}

int totalDigits(ll i) {
	return i > 0 ? (int) log10 ((double) i) + 1 : 1;
}

vector<bool> isPrime(primeSize, true);
vector<int> arePrimes;
void make_seive() {
	isPrime[0] = false;
	isPrime[1] = false;

	for (int i = 2; i <= sqrt(primeSize); i++)
		if (isPrime[i])
			for (int j = i * 2; j <= primeSize; j += i)
				isPrime[j] = false;

	for (int i = 2; i < primeSize; i++)
		if (isPrime[i])
			arePrimes.push_back(i);
}
endsnippet

snippet print "printing templates"
/* For printing 1-D array */
template<typename t> inline void print(const t& v) {
	for (const auto& i : v) {
		std::cout << i << " ";
	} std::cout << '\n';
}

/* For printing Pair*/
template<typename t> inline void printt(const t& v) {
	for (const auto& i : v) {
		std::cout << i.first << " " << i.second << '\n';
	} std::cout << '\n';
}

/* For printing Tree/Graph */
template<typename t> inline void printd(const t& v) {
	for (int i = 1; i <= v.size(); i++) {
		std::cout << i << ": ";
		for (const auto& j: v[i]) {
			std::cout << j << ' ';
		} std::cout << '\n';
	}
}
endsnippet


snippet debug "Debugging lines"
#define debug(x) cout << " -> [ " << #x << " = " << x << "]\n"
#define debug2(x, y) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " ]\n"
#define debug3(x, y, z) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " , " << #z << " = " << z << " ]\n";
#define debug4(x, y, z, xx) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " , " << #z << " = " << z << " , " << #xx << " = " << xx << " ]\n";
endsnippet

snippet cpp "c++ basic snippets"
/* THINK ALOUD !! */
#include <bits/stdc++.h>

using namespace std;
using ll=long long int;
using lld=long double;

#define mp make_pair
#define pb push_back
#define accu accumulate

#define vi vector<int>
#define vb vector<bool>
#define vc vector<char>
#define vd vector<double>
#define vlld vector<long double>
#define vll vector<long long int>

#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvd vector<vector<double>>
#define vvlld vector<vector<long double>>
#define vvll vector<vector<long long int>>

#define pll pair<ll, ll>
#define pii pair<int, int>
#define pci pair<char, int>
#define pic pair<int, char>
#define pls pair<ll, string>
#define psl pair<string, ll>
#define pis pair<int, string>
#define psi paid<string, int>
#define fast std::ios_base::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);

#define INF (int)1e9 // for INT_MAX which still allows for INF + INF
#define rep(i, a, n) for (ll i = a; i < n; i++)
#define per(i, a, n) for (ll i = n-1; i >= a; i--)
#define repp(i, a, n, p) for (ll i = a; i < n; i += p)
#define all(c) (c).begin(), (c).end()
#define lla(c) (c).rbegin(), (c).rend()
#define print_arr(arr, n) for (int i = 0; i < n; i++) std::cout << arr[i] << ' '; std::cout << '\n';
#define mod 1000000007
#define primeSize 2000000

void solve() {

}

int main() {
	fast;
	int t = 1;
	cin >> t;
	while (t--)
		solve();
}
endsnippet

snippet fcpp "c++ full template"
/* THINK ALOUD !! */
#include <bits/stdc++.h>
#define debug(x) cout << " -> [ " << #x << " = " << x << "]\n"
#define debug2(x, y) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " ]\n"
#define debug3(x, y, z) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " , " << #z << " = " << z << " ]\n";
#define debug4(x, y, z, xx) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " , " << #z << " = " << z << " , " << #xx << " = " << xx << " ]\n";

using namespace std;
using ll=long long int;
using lld=long double;

#define mp make_pair
#define pb push_back
#define accu accumulate

#define vi vector<int>
#define vb vector<bool>
#define vc vector<char>
#define vd vector<double>
#define vlld vector<long double>
#define vll vector<long long int>

#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvd vector<vector<double>>
#define vvlld vector<vector<long double>>
#define vvll vector<vector<long long int>>

#define pll pair<ll, ll>
#define pii pair<int, int>
#define pci pair<char, int>
#define pic pair<int, char>
#define pls pair<ll, string>
#define psl pair<string, ll>
#define pis pair<int, string>
#define psi paid<string, int>
// #define x first
// #define y second
#define fast std::ios_base::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);

#define INF (int)1e9 // for INT_MAX which still allows for INF + INF
#define rep(i, a, n) for (ll i = a; i < n; i++)
#define per(i, a, n) for (ll i = n-1; i >= a; i--)
#define repp(i, a, n, p) for (ll i = a; i < n; i += p)
#define all(c) (c).begin(), (c).end()
#define lla(c) (c).rbegin(), (c).rend()
#define print_arr(arr, n) for (int i = 0; i < n; i++) std::cout << arr[i] << ' '; std::cout << '\n';
#define mod 1000000007
#define primeSize 2000000

/* For printing 1-D array */
template<typename t> inline void print(const t& v) {
	for (const auto& i : v) {
		std::cout << i << " ";
	} std::cout << '\n';
}

/* For printing Pair*/
template<typename t> inline void printt(const t& v) {
	for (const auto& i : v) {
		std::cout << i.first << " " << i.second << '\n';
	} std::cout << '\n';
}

/* For printing Tree/Graph */
template<typename t> inline void printd(const t& v) {
	for (int i = 1; i <= v.size(); i++) {
		std::cout << i << ": ";
		for (const auto& j: v[i]) {
			std::cout << j << ' ';
		} std::cout << '\n';
	}
}

template <typename INT> INT GCD(INT a, INT b) {
	//     if (b == 0) return a;
	//     return gcd(b, a%b);
	return b ? gcd(b, a%b) : a;
}


template <typename INT> INT LCM(INT a, INT b) {
	return a / gcd(a, b) * b;
}

template <typename INT> std::map<INT, int> factorize(INT n) {
	map<INT, int> mp;
	for (INT i = 2; i * i <= n; i++) {
		while (n % i == 0) {
			n /= i;
			mp[i] ++;
		}
	}

	if (n > 1) mp[n] += 1;
	return mp;
}

void setIO(string name = "") { // name is nonempty for USACO file I/O
	// ios_base::sync_with_stdio(0); cin.tie(0); // see Fast Input & Output
	// alternatively, cin.tie(0)->sync_with_stdio(0);
	if (!name.empty()) {
		freopen((name+".in").c_str(), "r", stdin); // see Input & Output
		freopen((name+".out").c_str(), "w", stdout);
	}
}

ll bin_pow(ll a, ll b) {
	if (b == 0) return 1;
	long long res = bin_pow(a, b / 2);
	if (b % 2) return res * res * a;
	else return res * res;
}

int totalDigits(ll i) {
	return i > 0 ? (int) log10 ((double) i) + 1 : 1;
}

vector<bool> isPrime(primeSize, true);
vector<int> arePrimes;
void make_seive() {
	isPrime[0] = false;
	isPrime[1] = false;

	for (int i = 2; i <= sqrt(primeSize); i++)
		if (isPrime[i])
			for (int j = i * 2; j <= primeSize; j += i)
				isPrime[j] = false;

	for (int i = 2; i < primeSize; i++)
		if (isPrime[i])
			arePrimes.push_back(i);
}


void solve() {

}

int main() {
	// setIO();
	// make_seive();
	fast;
	int t = 1;
	cin >> t;
	while (t--)
		solve();
}
endsnippet

snippet bits "Bit manipulation template"
string dec_to_bin (int n) {
	string binary = std::bitset <8> ( n ).to_string ( );
	return binary;
}

unsigned long bin_to_dec (string s) {
	unsigned long decimal = std::bitset <8> ( s ).to_ulong ( );
	return decimal;
}

unsigned int next_power_of2 (unsigned int v) {
	//    unsigned int v; // compute the next highest power of 2 of 32-bit v
	v--;
	v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16;
	v++;
	return v;
}

template<typename INT> bool oppositeSigns(INT x, INT y) {
	return ((x ^ y) < 0);
}

bool isPowerOfTwo(int n) {
	return ((n) & (n - 1)) == 0);
}
endsnippet

snippet leet "leet Code template"
#include <bits/stdc++.h>
using namespace std;
using ll=long long int;
using lld=long double;
#define fast std::ios_base::sync_with_stdio(0);std::cin.tie(0);


#define rep(i, a, n) for (ll i = a; i < n; i++)
#define per(i, a, n) for (ll i = n-1; i >= a; i--)
#define all(c) (c).begin(), (c).end()
#define lla(c) (c).rbegin(), (c).rend()
#define mod 1000000007

class Solution {
	public:
		// Leetcode function

		void check() {
			int n;      cin >> n;
			int target; cin >> target;

			vector<int> arr(n);
			for (auto& i: arr) cin >> i;

			// Leetcode function calling
			auto ans = twoSum(arr, target);

			for (int i = 0; i <ans.size(); i++)
				cout << ans[i] << ' ';
		}
};

int main() {
	fast;
	Solution s; // s variable of solution type
	s.check();
}

endsnippet
