"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const settings_1 = tslib_1.__importDefault(require("./settings"));
const constants_1 = require("./constants");
const commands_1 = require("./commands");
const buffered_message_queue_1 = tslib_1.__importDefault(require("./buffered-message-queue"));
const validate_1 = require("./validate");
const connection = vscode_languageserver_1.createConnection();
const documents = new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
documents.listen(connection);
const settings = new settings_1.default(connection);
const messageQueue = new buffered_message_queue_1.default(connection);
validate_1.registerValidateHandlers(connection, messageQueue, documents, settings);
commands_1.registerCommandHandlers(connection, messageQueue, documents, settings);
let clientCapabilities = {};
connection.onInitialize((param) => {
    clientCapabilities = param.capabilities;
    settings.initialize(clientCapabilities);
    return {
        capabilities: {
            codeActionProvider: true,
            documentFormattingProvider: true,
            executeCommandProvider: {
                commands: [
                    constants_1.CommandIds.applyAutoFixes,
                    constants_1.DisableRuleCommandIds.applyDisableRuleInline,
                    constants_1.DisableRuleCommandIds.applyDisableRuleToFile,
                    constants_1.DisableRuleCommandIds.applyDisableRuleToLine,
                    constants_1.DisableRuleCommandIds.applyDisableRuleToRange,
                ],
            },
            textDocumentSync: {
                openClose: true,
                change: vscode_languageserver_1.TextDocumentSyncKind.Full,
                willSaveWaitUntil: true,
                save: {
                    includeText: false,
                },
            },
        },
    };
});
connection.onInitialized(() => {
    if (clientCapabilities.workspace &&
        clientCapabilities.workspace.didChangeConfiguration &&
        clientCapabilities.workspace.didChangeConfiguration.dynamicRegistration) {
        connection.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type, undefined);
    }
});
connection.onDidChangeConfiguration((params) => {
    settings.clientConfigurationChanged(params);
    validate_1.validateAll(messageQueue, documents.all());
});
documents.onDidClose((event) => {
    settings.closeDocument(event.document);
});
const exitNotification = new vscode_languageserver_1.NotificationType("stylelint/exit");
const nodeExit = process.exit;
process.exit = ((code) => {
    const stack = new Error("stack");
    connection.sendNotification(exitNotification, [code ? code : 0, stack.stack]);
    setTimeout(() => {
        nodeExit(code);
    }, 1000);
});
process.on("uncaughtException", (error) => {
    let message = error.message;
    if (error.stack) {
        message = `${message}\n\n${error.stack}`;
    }
    connection.console.error(`Uncaught exception: ${message}`);
});
connection.console.info(`stylelint running in node ${process.version}`);
connection.listen();
