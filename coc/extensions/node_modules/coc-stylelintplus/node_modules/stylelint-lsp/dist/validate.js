"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerValidateHandlers = exports.validateAll = exports.validateDocument = exports.autoFix = exports.validateNotification = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const fast_diff_1 = tslib_1.__importDefault(require("fast-diff"));
const path_1 = tslib_1.__importDefault(require("path"));
const STYLELINT_CONFIG_FILES = [
    ".stylelintignore",
    "stylelint.config.js",
    ".stylelintrc",
    ".stylelintrc.json",
    ".stylelintrc.yaml",
    ".stylelintrc.yml",
    ".stylelintrc.js",
    "package.json",
];
exports.validateNotification = new vscode_languageserver_1.NotificationType("stylelint/validate");
function lint(uri, code, settings, fix = false) {
    const parsedUri = vscode_uri_1.URI.parse(uri);
    let codeFilename = undefined;
    if (parsedUri.scheme === "file") {
        codeFilename = parsedUri.fsPath;
    }
    return settings.stylelint.lint({
        code,
        codeFilename,
        config: settings.config,
        configFile: settings.configFile,
        configOverrides: settings.configOverrides,
        fix,
        formatter: () => "",
    });
}
async function validate(connection, document, settings) {
    const { results: [result], } = await lint(document.uri, document.getText(), settings);
    if (result.ignored) {
        connection.sendDiagnostics({
            uri: document.uri,
            diagnostics: [],
        });
        return;
    }
    connection.sendDiagnostics({
        uri: document.uri,
        diagnostics: result.warnings.map((warning) => {
            const position = vscode_languageserver_1.Position.create(warning.line - 1, warning.column - 1);
            return {
                code: warning.rule,
                message: warning.text,
                range: vscode_languageserver_1.Range.create(position, position),
                severity: warning.severity === "warning"
                    ? vscode_languageserver_1.DiagnosticSeverity.Warning
                    : vscode_languageserver_1.DiagnosticSeverity.Error,
                source: "stylelintplus",
            };
        }),
    });
}
async function autoFix(document, settings) {
    const originalText = document.getText();
    const { output, results: [result], } = await lint(document.uri, originalText, settings, true);
    if (result.ignored || output === "") {
        return [];
    }
    const changes = [];
    let lastChange = undefined;
    let cur = 0;
    fast_diff_1.default(originalText, output).forEach(([action, str]) => {
        if (action === fast_diff_1.default.EQUAL) {
            cur += str.length;
        }
        else if (action === fast_diff_1.default.DELETE) {
            if (lastChange && lastChange.end === cur) {
                lastChange.end += str.length;
            }
            else {
                lastChange = { start: cur, end: cur + str.length, newText: "" };
                changes.push(lastChange);
            }
            cur += str.length;
        }
        else {
            if (lastChange && lastChange.end === cur) {
                lastChange.newText += str;
            }
            else {
                lastChange = { start: cur, end: cur, newText: str };
                changes.push(lastChange);
            }
        }
    });
    return changes.map(({ start, end, newText }) => vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(document.positionAt(start), document.positionAt(end)), newText));
}
exports.autoFix = autoFix;
function validateDocument(messageQueue, document) {
    messageQueue.addNotification(exports.validateNotification, document, document.version);
}
exports.validateDocument = validateDocument;
function validateAll(messageQueue, documents) {
    documents.forEach((document) => {
        validateDocument(messageQueue, document);
    });
}
exports.validateAll = validateAll;
function registerValidateHandlers(connection, messageQueue, documents, settings) {
    const needsValidation = new Set();
    messageQueue.onNotification(exports.validateNotification, async (identifier) => {
        const document = documents.get(identifier.uri);
        if (!document) {
            return;
        }
        const config = await settings.resolve(document);
        if (config.enable) {
            await validate(connection, document, config);
        }
        else {
            connection.sendDiagnostics({
                uri: document.uri,
                diagnostics: [],
            });
        }
    }, (document) => document.version);
    documents.onDidOpen(async (event) => {
        const config = await settings.resolve(event.document);
        if (config.enable) {
            validateDocument(messageQueue, event.document);
        }
    });
    documents.onDidChangeContent(async (params) => {
        const config = await settings.resolve(params.document);
        if (config.enable &&
            (config.validateOnType || needsValidation.has(params.document.uri))) {
            needsValidation.delete(params.document.uri);
            validateDocument(messageQueue, params.document);
        }
    });
    documents.onWillSaveWaitUntil(async (event) => {
        if (event.reason === vscode_languageserver_1.TextDocumentSaveReason.AfterDelay) {
            return [];
        }
        const config = await settings.resolve(event.document);
        if (!config.enable || !config.autoFixOnSave) {
            return [];
        }
        needsValidation.add(event.document.uri);
        return autoFix(event.document, config);
    });
    documents.onDidSave(async (event) => {
        const config = await settings.resolve(event.document);
        if (config.enable &&
            (config.validateOnSave ||
                config.autoFixOnSave ||
                needsValidation.has(event.document.uri))) {
            needsValidation.delete(event.document.uri);
            validateDocument(messageQueue, event.document);
        }
    });
    documents.onDidClose((event) => {
        connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
    });
    connection.onDocumentFormatting(async (params) => {
        const document = documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        const config = await settings.resolve(document);
        if (!config.enable || !config.autoFixOnFormat) {
            return [];
        }
        needsValidation.add(document.uri);
        return autoFix(document, config);
    });
    connection.onDidChangeWatchedFiles(async (params) => {
        const revalidate = params.changes.some((change) => {
            const uri = vscode_uri_1.URI.parse(change.uri);
            const filename = path_1.default.basename(uri.fsPath);
            return STYLELINT_CONFIG_FILES.includes(filename);
        });
        if (revalidate) {
            validateAll(messageQueue, documents.all());
        }
    });
}
exports.registerValidateHandlers = registerValidateHandlers;
