"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRequest = exports.isThenable = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
function isThenable(value) {
    return value && typeof value.then === "function";
}
exports.isThenable = isThenable;
function isRequest(value) {
    return value && value.resolve && value.reject;
}
exports.isRequest = isRequest;
class BufferedMessageQueue {
    constructor(connection) {
        this.connection = connection;
        this.queue = [];
        this.requestHandlers = new Map();
        this.notificationHandlers = new Map();
    }
    onRequest(type, handler, versionLens) {
        this.connection.onRequest(type, (param, token) => {
            return new Promise((resolve, reject) => {
                this.queue.push({
                    method: type.method,
                    param,
                    documentVersion: versionLens(param),
                    resolve,
                    reject,
                    token,
                });
                this.next();
            });
        });
        this.requestHandlers.set(type.method, {
            handler,
            versionLens,
        });
    }
    onNotification(type, handler, versionLens) {
        this.connection.onNotification(type, param => {
            this.addNotification(type, param, versionLens(param));
        });
        this.notificationHandlers.set(type.method, {
            handler,
            versionLens,
        });
    }
    addNotification(type, param, documentVersion) {
        this.queue.push({
            method: type.method,
            param,
            documentVersion,
        });
        this.next();
    }
    next() {
        if (this.timer || this.queue.length === 0) {
            return;
        }
        this.timer = setImmediate(() => {
            this.timer = undefined;
            this.popQueue();
        });
    }
    popQueue() {
        const message = this.queue.shift();
        if (!message) {
            return;
        }
        if (isRequest(message)) {
            if (message.token && message.token.isCancellationRequested) {
                message.reject(new vscode_languageserver_1.ResponseError(vscode_languageserver_1.ErrorCodes.RequestCancelled, "Request was cancelled."));
                this.next();
                return;
            }
            const handlerAndLens = this.requestHandlers.get(message.method);
            if (!handlerAndLens) {
                this.next();
                return;
            }
            const { handler, versionLens } = handlerAndLens;
            if (message.documentVersion !== versionLens(message.param)) {
                message.reject(new vscode_languageserver_1.ResponseError(vscode_languageserver_1.ErrorCodes.RequestCancelled, "Request was cancelled."));
                this.next();
                return;
            }
            const result = handler(message.param, message.token);
            if (isThenable(result)) {
                result.then(value => {
                    message.resolve(value);
                }, error => {
                    message.reject(error);
                });
            }
            else {
                message.resolve(result);
            }
        }
        else {
            const handlerAndLens = this.notificationHandlers.get(message.method);
            if (!handlerAndLens) {
                this.next();
                return;
            }
            const { handler, versionLens } = handlerAndLens;
            if (message.documentVersion !== versionLens(message.param)) {
                this.next();
                return;
            }
            handler(message.param);
        }
        this.next();
    }
}
exports.default = BufferedMessageQueue;
