"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCommandHandlers = exports.buildExecuteCommandHandler = exports.buildCodeActionHandler = exports.shouldApplyToWholeFile = exports.shouldApplyToLine = exports.DISABLE_RULE_TEXT_EDITS = exports.getIndent = exports.DISABLE_RULES_FOR_WHOLE_FILE = exports.DISABLE_RULES_FOR_RANGE = exports.DISABLE_RULES_FOR_LINE = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const constants_1 = require("./constants");
const validate_1 = require("./validate");
exports.DISABLE_RULES_FOR_LINE = [
    constants_1.DisableRuleCommandIds.applyDisableRuleInline,
    constants_1.DisableRuleCommandIds.applyDisableRuleToLine,
    constants_1.DisableRuleCommandIds.applyDisableRuleToFile,
];
exports.DISABLE_RULES_FOR_RANGE = [
    constants_1.DisableRuleCommandIds.applyDisableRuleToRange,
    constants_1.DisableRuleCommandIds.applyDisableRuleToFile,
];
exports.DISABLE_RULES_FOR_WHOLE_FILE = [
    constants_1.DisableRuleCommandIds.applyDisableRuleToFile,
];
function getIndent(line) {
    return line.match(/^\s*/)[0];
}
exports.getIndent = getIndent;
exports.DISABLE_RULE_TEXT_EDITS = {
    [constants_1.DisableRuleCommandIds.applyDisableRuleInline]: (document, range, rule) => {
        const lineNr = range.start.line;
        const line = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineNr, 0), vscode_languageserver_1.Position.create(lineNr + 1, 0)));
        const character = line.length - (line.endsWith("\r\n") ? 2 : line.endsWith("\n") ? 1 : 0);
        const newText = ` /* stylelint-disable-line ${rule} */`;
        return [vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(lineNr, character), newText)];
    },
    [constants_1.DisableRuleCommandIds.applyDisableRuleToLine]: (document, range, rule) => {
        const lineNr = range.start.line;
        const line = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineNr, 0), vscode_languageserver_1.Position.create(lineNr + 1, 0)));
        const indent = getIndent(line);
        const newText = `${indent}/* stylelint-disable-next-line ${rule} */\n`;
        return [vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(lineNr, 0), newText)];
    },
    [constants_1.DisableRuleCommandIds.applyDisableRuleToFile]: (_document, _range, rule) => {
        const newText = `/* stylelint-disable ${rule} */\n`;
        return [vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(0, 0), newText)];
    },
    [constants_1.DisableRuleCommandIds.applyDisableRuleToRange]: (document, range, rule) => {
        const startLineNr = range.start.line;
        const startLine = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startLineNr, 0), vscode_languageserver_1.Position.create(startLineNr + 1, 0)));
        const startIndent = getIndent(startLine);
        const startNewText = `${startIndent}/* stylelint-disable ${rule} */\n`;
        const endLineNr = range.end.line;
        let endLine = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(endLineNr, 0), vscode_languageserver_1.Position.create(endLineNr + 1, 0)));
        if (endLine === "" || endLine === "\r\n" || endLine === "\n") {
            endLine = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(endLineNr - 1, 0), vscode_languageserver_1.Position.create(endLineNr, 0)));
        }
        const endIndent = getIndent(endLine);
        const endNewText = `${endIndent}/* stylelint-enable ${rule} */\n`;
        return [
            vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(startLineNr, 0), startNewText),
            vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(endLineNr + 1, 0), endNewText),
        ];
    },
};
function isApplyAutoFixesCommand(params) {
    return Boolean(params.command === constants_1.CommandIds.applyAutoFixes);
}
function isDisableRuleCommand(params) {
    return Boolean(exports.DISABLE_RULE_TEXT_EDITS[params.command]);
}
function shouldApplyToLine(range) {
    return (range.start.line === range.end.line ||
        (range.end.character === 0 && range.start.line + 1 === range.end.line));
}
exports.shouldApplyToLine = shouldApplyToLine;
function shouldApplyToWholeFile(range, lineCount) {
    return (range.start.line === 0 &&
        (range.end.line === lineCount - 1 || range.end.line === lineCount));
}
exports.shouldApplyToWholeFile = shouldApplyToWholeFile;
function buildCodeActionHandler(documents, settings) {
    return (params) => {
        const document = documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        const results = [];
        const { range } = params;
        const applyToLine = shouldApplyToLine(range);
        const applyToWholeFile = shouldApplyToWholeFile(range, document.lineCount);
        let returnSource = true;
        let returnQuickFixes = true;
        if (params.context.only) {
            returnSource = params.context.only.includes(vscode_languageserver_1.CodeActionKind.Source);
            returnQuickFixes = params.context.only.includes(vscode_languageserver_1.CodeActionKind.QuickFix);
        }
        if (returnSource && applyToWholeFile) {
            const supportsCodeActionLiterals = settings.supportedCodeActionLiterals.includes(vscode_languageserver_1.CodeActionKind.Source);
            const title = constants_1.CommandTitles[constants_1.CommandIds.applyAutoFixes];
            const command = vscode_languageserver_1.Command.create(title, constants_1.CommandIds.applyAutoFixes, vscode_languageserver_1.VersionedTextDocumentIdentifier.create(document.uri, document.version));
            if (supportsCodeActionLiterals) {
                results.push({
                    title,
                    kind: vscode_languageserver_1.CodeActionKind.Source,
                    command,
                });
            }
            else {
                results.push(command);
            }
        }
        if (returnQuickFixes) {
            const rules = new Map();
            params.context.diagnostics.forEach((diagnostic) => {
                if (typeof diagnostic.code === "string" && diagnostic.code !== "") {
                    const diagnostics = rules.get(diagnostic.code);
                    if (diagnostics) {
                        diagnostics.push(diagnostic);
                    }
                    else {
                        rules.set(diagnostic.code, [diagnostic]);
                    }
                }
            });
            const disableRuleCommands = applyToLine
                ? exports.DISABLE_RULES_FOR_LINE
                : applyToWholeFile
                    ? exports.DISABLE_RULES_FOR_WHOLE_FILE
                    : exports.DISABLE_RULES_FOR_RANGE;
            const supportsCodeActionLiterals = settings.supportedCodeActionLiterals.includes(vscode_languageserver_1.CodeActionKind.QuickFix);
            rules.forEach((diagnostics, rule) => {
                disableRuleCommands.forEach((disableKey) => {
                    const title = `${constants_1.CommandTitles[disableKey]}: ${rule}`;
                    if (supportsCodeActionLiterals) {
                        results.push({
                            title,
                            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
                            diagnostics,
                            edit: {
                                changes: {
                                    [params.textDocument.uri]: exports.DISABLE_RULE_TEXT_EDITS[disableKey](document, range, rule),
                                },
                            },
                        });
                    }
                    else {
                        results.push(vscode_languageserver_1.Command.create(title, disableKey, vscode_languageserver_1.VersionedTextDocumentIdentifier.create(document.uri, document.version), range, rule));
                    }
                });
            });
        }
        return results;
    };
}
exports.buildCodeActionHandler = buildCodeActionHandler;
function buildExecuteCommandHandler(connection, messageQueue, documents, settings) {
    return async (params) => {
        let document;
        let label = "";
        let edits = [];
        if (isApplyAutoFixesCommand(params)) {
            const { arguments: [documentIdentifier], } = params;
            document = documents.get(documentIdentifier.uri);
            if (!document) {
                return;
            }
            label = constants_1.CommandTitles[constants_1.CommandIds.applyAutoFixes];
            const config = await settings.resolve(document);
            edits = await validate_1.autoFix(document, config);
        }
        else if (isDisableRuleCommand(params)) {
            const { command, arguments: [documentIdentifier, range, rule], } = params;
            document = documents.get(documentIdentifier.uri);
            if (!document) {
                return;
            }
            label = `${constants_1.CommandTitles[command]}: ${rule}`;
            edits = exports.DISABLE_RULE_TEXT_EDITS[command](document, range, rule);
        }
        if (document && edits.length) {
            const workspaceEdits = {
                label,
                edit: {
                    changes: {
                        [document.uri]: edits,
                    },
                },
            };
            const result = await connection.workspace.applyEdit(workspaceEdits);
            if (result.applied) {
                document = documents.get(document.uri);
                if (document) {
                    validate_1.validateDocument(messageQueue, document);
                }
            }
            else {
                let msg = `Could not apply edit "${label}"`;
                if (result.failedChange) {
                    msg = `${msg}: ${result.failedChange}`;
                }
                connection.console.error(msg);
            }
        }
    };
}
exports.buildExecuteCommandHandler = buildExecuteCommandHandler;
function registerCommandHandlers(connection, messageQueue, documents, settings) {
    connection.onCodeAction(buildCodeActionHandler(documents, settings));
    messageQueue.onRequest(vscode_languageserver_1.ExecuteCommandRequest.type, buildExecuteCommandHandler(connection, messageQueue, documents, settings), ({ arguments: args }) => args && args[0] && args[0].version);
}
exports.registerCommandHandlers = registerCommandHandlers;
