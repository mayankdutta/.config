# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt


snippet cpp "c++ basic snippets"
#include <bits/stdc++.h>
using namespace std;
using ll=long long int;
using lld=long double;

#define fast std::ios_base::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);


#define rep(i, a, n) for (ll i = a; i < n; i++)
#define per(i, a, n) for (ll i = n-1; i >= a; i--)
#define all(c) (c).begin(), (c).end()
#define lla(c) (c).rbegin(), (c).rend()
#define mod 1000000007

template <typename t> inline void print(const t & v) {
		for (const auto& i : v) {
				std::cout << i << " ";
		} std::cout << '\n';
}

template <typename t> inline void printt(const t & v) {
		for (const auto& i : v) {
				std::cout << i.first << " " << i.second << '\n';
		} std::cout << '\n';
}

void solve() {
		${1}
}

int main() {
		fast;
		solve();
}
endsnippet

snippet fcpp "c++ full template"
//THINK ALOUD !!
#include <bits/stdc++.h>
#define debug(x) cout << " -> [ " << #x << " = " << x << "]\n"
#define debug2(x, y) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " ]\n"
#define debug3(x, y, z) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " , " << #z << " = " << z << " ]\n";
#define debug4(x, y, z, xx) cout << " -> [ " << #x << " = " << x << " , " << #y << " = " << y << " , " << #z << " = " << z << " , " << #xx << " = " << xx << " ]\n";

using namespace std;
using ll=long long int;
using lld=long double;
#define mp make_pair
#define pb push_back
#define accu accumulate

#define pll pair<ll, ll>
#define pii pair<int, int>
#define pci pair<char, int>
#define pic pair<int, char>
#define pls pair<ll, string>
#define psl pair<string, ll>
#define pis pair<int, string>
#define psi paid<string, int>
// #define x first
// #define y second
#define fast std::ios_base::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);


#define rep(i, a, n) for (ll i = a; i < n; i++)
#define per(i, a, n) for (ll i = n-1; i >= a; i--)
#define repp(i, a, n, p) for (ll i = a; i < n; i += p)
#define all(c) (c).begin(), (c).end()
#define lla(c) (c).rbegin(), (c).rend()
#define print_arr(arr, n) for (int i = 0; i < n; i++) std::cout << arr[i] << ' '; std::cout << '\n';
#define mod 1000000007
#define primeSize 2000000

template <typename t> inline void print(const t & v) {
		for (const auto& i : v) {
				std::cout << i << " ";
		} std::cout << '\n';
}

template <typename t> inline void printt(const t & v) {
		for (const auto& i : v) {
				std::cout << i.first << " " << i.second << '\n';
		} std::cout << '\n';
}

template <typename INT> INT GCD(INT a, INT b) {
		//     if (b == 0) return a;
		//     return gcd(b, a%b);
		return b ? gcd(b, a%b) : a;
}


template <typename INT> INT LCM(INT a, INT b) {
		return a / gcd(a, b) * b;
}

template <typename INT> std::map<INT, int> factorize(INT n) {
		map<INT, int> mp;
		for (INT i = 2; i * i <= n; i++) {
				while (n % i == 0) {
						n /= i;
						mp[i] ++;
				}
		}

		if (n > 1) mp[n] += 1;
		return mp;
}

void setIO(string name = "") { // name is nonempty for USACO file I/O
		// ios_base::sync_with_stdio(0); cin.tie(0); // see Fast Input & Output
		// alternatively, cin.tie(0)->sync_with_stdio(0);
		if (!name.empty()) {
				freopen((name+".in").c_str(), "r", stdin); // see Input & Output
				freopen((name+".out").c_str(), "w", stdout);
		}
}

ll bin_pow(ll a, ll b) {
		if (b == 0) return 1;
		long long res = bin_pow(a, b / 2);
		if (b % 2) return res * res * a;
		else return res * res;
}

int totalDigits(ll i) {
		return i > 0 ? (int) log10 ((double) i) + 1 : 1;
}

vector<bool> isPrime(primeSize, true);
vector<int> arePrimes;
void make_seive() {
		isPrime[0] = false;
		isPrime[1] = false;

		for (int i = 2; i <= sqrt(primeSize); i++) {
				if (isPrime[i]) {
						for (int j = i * 2; j <= primeSize; j += i) {
								isPrime[j] = false;
						}
				}
		}

		for (int i = 2; i < primeSize; i++) {
				if (isPrime[i]) {
						arePrimes.push_back(i);
				}
		}
}


void solve() {
		${2}
}

int main() {
		// setIO();
		fast;
		int t = 1;
		//make_seive();
		${1}cin >> t;
		while (t--)
				solve();
}

endsnippet

snippet bits "Bit manipulation template"
string dec_to_bin (int n) {
	string binary = std::bitset <8> ( n ).to_string ( );
	return binary;
}

unsigned long bin_to_dec (string s) {
	unsigned long decimal = std::bitset <8> ( s ).to_ulong ( );
	return decimal;
}

unsigned int next_power_of2 (unsigned int v) {
	//    unsigned int v; // compute the next highest power of 2 of 32-bit v
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

template<typename INT> bool oppositeSigns(INT x, INT y) {
	return ((x ^ y) < 0);  // True if x and y have opposite signs.
	// source :: http://graphics.stanford.edu/~seander/bithacks.html
}

bool isPowerOfTwo(int n) {
	return (n & (n - 1) == 0); // note that 0 is considered incorrectly as power of 2
}
endsnippet
